setUp:
mov r5,#528
sub r0,r5,#1
str r0,body1			
sub r0,r5,#2					
str r0,body0	
mov r2,#0 
mov r1,#0xffffff
ldr r3,bodyAddr
add r4,r3,#1
mov r6,#768
sub r6,r6,#1
mov r7,#1024
sub r7,r7,#1				// 1023 in r7
mov r11,#68 //Move right initially

createApple:
inp r8,8	// gets a random 32 bit pattern
and r8,r8,r7	// r7 has 1023
cmp r8,r6	// r6 has 767
bgt createApple // restrict random range
add r8,r8,#256
cmp r8,r9
beq createApple 
inp r9,8  //r9 is Apple colour (random 32-bit pattern)

moveSnake:
str r9,[r8]	// draw apple
inp r0,4  // get latest key pressed

testKeys:
cmp r0,#87 //W key
beq up
cmp r0,#65 //A key
beq left
cmp r0,#68 //D key
beq right
cmp r0,#83 //S key
beq down
mov r0, r11
b testKeys

up:
cmp r11,#83
beq down
mov r11,#87
sub r5,r5,#32
cmp r5,#256
blt over
b afterMove

left:
cmp r11,#68
beq right
mov r11,#65	
sub r5,r5,#1
and r0,r5,#31
cmp r0,#31
beq over
b afterMove

right:
cmp r11,#65
beq left
mov r11,#68	
add r5,r5,#1
and r0,r5,#31
cmp r0,#0
beq over
b afterMove

down:
cmp r11,#87
beq up
mov r11,#83
add r5,r5,#32
add r0,r6,#256
cmp r5,r0
bgt over

afterMove:
cmp r8,r5 // check if caught apple
beq clearApple

moveRear:
ldr r0,[r3]
str r1,[r0]  
add r3,r3,#1
cmp r3,#200
blt moveFront
ldr r3,bodyAddr
b moveFront

clearApple:
mov r8,#0

moveFront:
str r5,[r4]		// add to list (for later tail delete)
add r4,r4,#1
cmp r4,#200
blt checkForCrossing
ldr r4, bodyAddr 

checkForCrossing: // check if the snake has hit itself
ldr r0,[r5] // read colour of pixel head is moving onto
cmp r0,#0  //If it is black (already occupied by snake body)...
beq over

checkForMaxLength:
cmp r3,r4 //If the front has caught up with the tail, then the body data is full
beq over 

drawHead:
str r2,[r5]  //This is easliest we can the head in its new position

repeat:
cmp r8, #0  //If no apple...
beq createApple //First create a new one
b moveSnake  //Otherwise just repeat the move cycle
	
over: 
halt

bodyAddr: dat body0
body0: dat 0
body1: dat 0