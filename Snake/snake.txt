// general setup
mov r12,#0x8000000		// video memory base in word mode (0x20000000)
mov r11,#2				// snake moves to right first
add r9,r12,#272			// initial snake head position
sub r0,r9,#1				// #271 (too many bits for an immediate)
str r0,body				// setup the snake body
sub r0,r0,#1
str r0,body1				// 2 segments to start

// it saves space to put these constants in registers
mov r7,#1024
sub r7,r7,#1				// 1023 in r7
mov r6,#768
sub r6,r6,#1				// 767 in r6
mov r0,#200
ldr r3,abody				// address of last snake segment
add r4,r3,#1				// place to put next first segment

// register use
// r12 video memory base
// r11 direction
// r10 spare
// r9  snake head position
// r8  apple position
// r7 the constant 1023
// r6 the constant 767
// r5 spare
// r4 pointer to snake first segment
// r3 pointer to snake last segment

// this code does not prevent the apple to appear in the snake body
// it should stay there and the snake will eventually leave it behind

// The original algorithm copied the segment list up memory as the
// snake moved. This slows down horribly as the snake gets longer.
// Now the segment list grows downwards and pointers move/wrap

// main loop
loop:
mov r11,#2
mvright: add r9,r9,#1
and r0,r9,#31
b drawHead

drawHead:
mov r0,#0				// black is 0
str r0,[r9]				// draw snake head

// delete the tail and move it
mvtail: ldr r1,[r3]
mvn r0,#0xff000000		// white is ffffff (MVN is NOT)
str r0,[r1]				// write tail as white
add r3,r3,#1				// step to next location
cmp r3,#200
bne mvhead
ldr r3,abody
b mvhead

// update the segment head pointer and save the head
mvhead: str r9,[r4]		// add to list (for later tail delete)
add r4,r4,#1
cmp r4,#200
bne draw
ldr r4,abody

b loop

abody: dat body
body: dat 0
body1: dat 0
// snake body extends from here to end of memory
